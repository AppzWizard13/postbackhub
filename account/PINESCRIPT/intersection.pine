// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// TradeWiz 
//@version=5
indicator("TradeWiz ", overlay = true, max_labels_count = 500, max_lines_count = 500, max_boxes_count = 500, max_bars_back = 500)

bullC       = input.color(defval = #14D990, title = "Bull Color", group = "Smart Money Concepts", inline = "7")
bearC       = input.color(defval = #F24968, title = "Bear Color", group = "Smart Money Concepts", inline = "7")
showInt     = input.bool(defval = true, title = "Show Internals", group = "Smart Money Concepts")
intSens     = input.int(3, "Internals Sensitivity", options =  [3 , 5 , 8 ], group = "Smart Money Concepts", inline = "20")
intStru     = input.string(defval = "All", title = "Internal Structure", options = ["All", "BoS", "CHoCH"], inline = "30", group = "Smart Money Concepts")
showExt     = input.bool(defval = true, title = "Show Externals" ,group = "Smart Money Concepts")
extSens     = input.int(25, "Externals Sensitivity", options = [10, 25, 50],group = "Smart Money Concepts", inline = "21")
extStru     = input.string(defval = "All", title = "External Structure", options = ["All", "BoS", "CHoCH"], inline = "31", group = "Smart Money Concepts")
showOB      = input.bool(defval = true, title = "Show Order Blocks" ,group = "Swing Blocks")
showLast    = input.int(defval = 10, title = "Swing Order Blocks", minval = 0, group = "Swing Blocks")
showHHLH    = input.bool(defval = true, title = "Show HH/LH", group = "Swing Blocks")
showHLLL    = input.bool(defval = true, title = "Show LH/LL", group = "Swing Blocks")
showAOE     = input.bool(defval = true, title = "Show Area of Interest", group = "Swing Blocks")
showFVG     = input.bool(defval = true, title = "Show Fair Value Gaps", group = "FVG")
contract    = input.bool(defval = false, title = "Contract Violated FVG", group = "FVG")
closeOnly   = input.bool(defval = false, title = "Show Closest Up/Down FVG Only", group = "FVG")
fvgcol      = input.color(defval = color.green, title = "FVG Color", group = "FVG")
fvgtra      = input.int(defval = 80, minval = 0, maxval = 100, title = "FVG Transparency", group = "FVG")
showFibs    = input.bool(defval = true, title = "Show Auto Fibs", group = "Auto Fibs")
showEMAs    = input.bool(defval = true, title = "Show EMA", group = "Auto Fibs")
// extSensFibs = input.int(25, "Fibs Sensitivity", options = [10, 25, 50], group = "Auto Fibs", inline = "22")

show0       = input.bool(defval = true,  title = "", inline = "0", group = "Auto Fibs")
show236     = input.bool(defval = true,  title = "", inline = "1", group = "Auto Fibs")
show382     = input.bool(defval = true,  title = "", inline = "2", group = "Auto Fibs")
show5       = input.bool(defval = true,  title = "", inline = "3", group = "Auto Fibs")
show618     = input.bool(defval = true,  title = "", inline = "4", group = "Auto Fibs")
show786     = input.bool(defval = true,  title = "", inline = "5", group = "Auto Fibs")
show1       = input.bool(defval = true,  title = "", inline = "6", group = "Auto Fibs")
show1618    = input.bool(defval = true,  title = "", inline = "7", group = "Auto Fibs")

// Fibonacci Levels
fib0        = input.float(defval = 0.00, title = "", minval = 0, step = 0.01, inline = "0", group = "Auto Fibs")
fib1        = input.float(defval = 0.236, title = "", minval = 0, step = 0.01, inline = "1", group = "Auto Fibs")
fib2        = input.float(defval = 0.382, title = "", minval = 0, step = 0.01, inline = "2", group = "Auto Fibs")
fib3        = input.float(defval = 0.5, title = "", minval = 0, step = 0.01, inline = "3", group = "Auto Fibs")
fib4        = input.float(defval = 0.618, title = "", minval = 0, step = 0.01, inline = "4", group = "Auto Fibs")
fib5        = input.float(defval = 0.786, title = "", minval = 0, step = 0.01, inline = "5", group = "Auto Fibs")
fib6        = input.float(defval = 1.0, title = "", minval = 0, step = 0.01, inline = "6", group = "Auto Fibs")
fib7        = input.float(defval = 1.618, title = "", minval = 0, step = 0.01, inline = "7", group = "Auto Fibs")

// Colors for Fibonacci Levels
fib0col     = input.color(title = "0%", defval = color.new(color.gray, 50), inline = "0", group = "Auto Fibs") // 0%
fib1col     = input.color(title = "23.6%", defval = color.new(#9370DB, 0), inline = "1", group = "Auto Fibs") // Light Purple
fib2col     = input.color(title = "38.2%", defval = #007FFF, inline = "2", group = "Auto Fibs") // Medium Blue
fib3col     = input.color(title = "50%", defval = #32CD32, inline = "3", group = "Auto Fibs") // Bright Green
fib4col     = input.color(title = "61.8%", defval = #FFA500, inline = "4", group = "Auto Fibs") // Bright Orange (most important)
fib5col     = input.color(title = "78.6%", defval = color.new(#00CED1, 0), inline = "5", group = "Auto Fibs") // Cyan
fib6col     = input.color(title = "100%", defval = color.new(color.gray, 20), inline = "6", group = "Auto Fibs") // Gray
fib7col     = input.color(title = "161.8%", defval = color.new(#FF7F7F, 0), inline = "7", group = "Auto Fibs") // Pale Red


crossoverlimit     = input.int(4, "Cross Over Limit", group="EMA", inline = "20")






// EMA visibility toggles
showShortest = input(true, title="Show 9 EMA" , group="EMA")
showMidShortest = input(true, title="Show 20 EMA" , group="EMA")
showShort = input(true, title="Show 50 EMA" , group="EMA")
showLonger = input(true, title="Show 100 EMA" , group="EMA")
showLongest = input(true, title="Show 200 EMA" , group="EMA")







// EMA thickness and colors
shortestColor = input.color(color.yellow, title="Color for 9 EMA" , group="EMA")
midShortestColor = input.color(color.red, title="Color for 20 EMA" , group="EMA")
shortColor = input.color(color.aqua, title="Color for 50 EMA" , group="EMA")
longerColor = input.color(color.orange, title="Color for 100 EMA" , group="EMA")
longestColor = input.color(color.blue, title="Color for 200 EMA" , group="EMA")

shortestThickness = input.int(1, title="Thickness for 9 EMA" , group="EMA")
midShortestThickness = input.int(2, title="Thickness for 20 EMA" , group="EMA")
shortThickness = input.int(3, title="Thickness for 50 EMA" , group="EMA")
longerThickness = input.int(4, title="Thickness for 100 EMA" , group="EMA")
longestThickness = input.int(5, title="Thickness for 200 EMA" , group="EMA")



// On/Off toggles for each EMA crossover
showCross9_20 = input.bool(true, title="Show 9-20 EMA Crossover" , group="EMA")
showCross20_50 = input.bool(true, title="Show 20-50 EMA Crossover" , group="EMA")
showCross50_100 = input.bool(true, title="Show 50-100 EMA Crossover" , group="EMA")
showCross100_200 = input.bool(true, title="Show 100-200 EMA Crossover" , group="EMA")


// EMA values
shortest = ta.ema(close, 9)
midshortest = ta.ema(close, 20)
short = ta.ema(close, 50)
longer = ta.ema(close, 100)
longest = ta.ema(close, 200)

// Plot the EMAs if the toggle is enabled
plot(showShortest ? shortest : na, color=shortestColor, title="9 EMA", linewidth=shortestThickness)
plot(showMidShortest ? midshortest : na, color=midShortestColor, title="20 EMA", linewidth=midShortestThickness)
plot(showShort ? short : na, color=shortColor, title="50 EMA", linewidth=shortThickness)
plot(showLonger ? longer : na, color=longerColor, title="100 EMA", linewidth=longerThickness)
plot(showLongest ? longest : na, color=longestColor, title="200 EMA", linewidth=longestThickness)


// Detect crossovers between EMAs
cross9_20_up = ta.crossover(shortest, midshortest)
cross9_20_down = ta.crossunder(shortest, midshortest)
cross20_50_up = ta.crossover(midshortest, short)
cross20_50_down = ta.crossunder(midshortest, short)
cross50_100_up = ta.crossover(short, longer)
cross50_100_down = ta.crossunder(short, longer)
cross100_200_up = ta.crossover(longer, longest)
cross100_200_down = ta.crossunder(longer, longest)

// Arrays to store lines and labels
var line[] crossLines = array.new_line(0)
var label[] crossLabels = array.new_label(0)


// Function to calculate the power percentage based on the formula
calculatestatusage(ema1, ema2, volume) =>
    cr_price = close
    // volumeFactor = volume
    volumeFactor = volume / ta.sma(volume, 20)  
    // Volume confirmation (if volume is above the 20-period average)
    // volumeAboveAvg = volume > ta.sma(volume, 20)// Normalize the volume with 20-period SMA

    // volumeFactor = volumeAboveAvg ? "good" : "low"

    [cr_price, volumeFactor]

// Function to create lines and labels, and manage array size
createLineAndLabel(price, labelText, lineColor, labelColor, lineThickness, cr_price, volumeFactor) =>
    // Define the length of the line
    lineLength = 100
    // Create a new line with a length of 100 bars
    newLine = line.new(x1=bar_index, y1=price, x2=bar_index + lineLength, y2=price, color=lineColor, width=lineThickness, style=line.style_solid)
    array.push(crossLines, newLine)
    // Create a label at the end of the line with power percentage and trend strength
    newLabel = label.new(x=bar_index + lineLength, y=price, 
                         text=labelText + "| Price: " + str.tostring(price, "#.###"), 
                         style=label.style_label_center, color=labelColor, textcolor=color.white, size=size.normal)
    array.push(crossLabels, newLabel)
    // If more than 4 items, remove the oldest ones
    if array.size(crossLines) > crossoverlimit
        line.delete(array.shift(crossLines))
    if array.size(crossLabels) > crossoverlimit
        label.delete(array.shift(crossLabels))

// Plot horizontal lines and labels for the latest crossovers
if cross9_20_up
    [cr_price, volumeFactor] = calculatestatusage(shortest, midshortest, volume)
    createLineAndLabel(close, "9-20 EMA Up", color.green, color.green, 1, cr_price, volumeFactor)

if cross9_20_down
    [cr_price, volumeFactor] = calculatestatusage(shortest, midshortest, volume)
    createLineAndLabel(close, "9-20 EMA Down", color.red, color.red, 1, cr_price, volumeFactor)

if cross20_50_up
    [cr_price, volumeFactor] = calculatestatusage(midshortest, short, volume)
    createLineAndLabel(close, "20-50 EMA Up", color.green, color.green, 3, cr_price, volumeFactor)

if cross20_50_down
    [cr_price, volumeFactor] = calculatestatusage(midshortest, short, volume)
    createLineAndLabel(close, "20-50 EMA Down", color.red, color.red, 3, cr_price, volumeFactor)

if cross50_100_up
    [cr_price, volumeFactor] = calculatestatusage(short, longer, volume)
    createLineAndLabel(close, "50-100 EMA Up", color.green, color.green, 5, cr_price, volumeFactor)

if cross50_100_down
    [cr_price, volumeFactor] = calculatestatusage(short, longer, volume)
    createLineAndLabel(close, "50-100 EMA Down", color.red, color.red, 5, cr_price, volumeFactor)

if cross100_200_up
    [cr_price, volumeFactor] = calculatestatusage(longer, longest, volume)
    createLineAndLabel(close, "100-200 EMA Up", color.green, color.green, 7, cr_price, volumeFactor)

if cross100_200_down
    [cr_price, volumeFactor] = calculatestatusage(longer, longest, volume)
    createLineAndLabel(close, "100-200 EMA Down", color.red, color.red, 7, cr_price, volumeFactor)


var bigData = map.new<string, float>()

if bigData.size() == 0

    bigData.put("moving", 0)
    bigData.put("upaxis", 0.0) 
    bigData.put("upaxis2", 0)
    bigData.put("dnaxis", 0.0) 
    bigData.put("dnaxis2", 0)
    bigData.put("upside", 1)
    bigData.put("downside", 1)

[pdHigh, pdLow, dayHigh, dayLow, pdBar, dayBar] = request.security(syminfo.tickerid, "1D", [high[1], low[1], high, low, time[1], time])

var highArr = array.new_float(), var lowArr  = array.new_float()
var timeArr = array.new_int  (), var volArr  = array.new_float()
var closeArr = array.new_float(), var openArr = array.new_float()

highArr.unshift(high), lowArr.unshift(low)
timeArr.unshift(time), volArr.unshift(volume)
closeArr.unshift(close), openArr.unshift(open)

type rollingTF 

    float highTF                  = 0
    float lowTF                   = 1e8
    int   highTFt                 = 0
    int   lowTFt                  = 0
    float volTF                   = 0
    map   <string, line >         rTFdraw
    map   <string, label>         rTFlabel

method tfDraw(int tfDiff, bool showRollingLab, string tf, bool showLevels) => 


    TFhrdata = rollingTF.new(), var volRolling = array.new<float>()

    if highArr.size() > tfDiff

        for i = 0 to tfDiff

            if showLevels and barstate.islast

                getHigh = highArr.get(i), getLow = lowArr.get(i), 
                             getTime = timeArr.get(i)

                TFhrdata.highTF := math.max(TFhrdata.highTF, getHigh)
                TFhrdata.lowTF  := math.min(TFhrdata.lowTF , getLow )

                if TFhrdata.highTF == getHigh 

                    TFhrdata.highTFt := timeArr.get(i)

                if TFhrdata.lowTF == getLow

                    TFhrdata.lowTFt  := timeArr.get(i)

            TFhrdata.volTF += volArr.get(i)

        volRolling.push(TFhrdata.volTF)

        var lineDraw = rollingTF.new(rTFdraw = map.new<string, line>(), rTFlabel = map.new<string, label>())

        if showLevels

            switch lineDraw.rTFdraw.size() == 0

                true =>  lineDraw.rTFdraw.put("High", line.new(TFhrdata.highTFt, TFhrdata.highTF, time, TFhrdata.highTF, 
                                                 xloc = xloc.bar_time, color = color.aqua)),
                         lineDraw.rTFdraw.put("Low" , line.new(TFhrdata.lowTFt , TFhrdata.lowTF , time, TFhrdata.lowTF , 
                                                 xloc = xloc.bar_time, color = color.aqua))  

                =>       lineDraw.rTFdraw.get("High").set_xy1(TFhrdata.highTFt, TFhrdata.highTF),
                         lineDraw.rTFdraw.get("High").set_xy2(time, TFhrdata.highTF),

                         lineDraw.rTFdraw.get("Low").set_xy1(TFhrdata.lowTFt, TFhrdata.lowTF),
                         lineDraw.rTFdraw.get("Low").set_xy2(time, TFhrdata.lowTF)

            if showRollingLab 

                switch lineDraw.rTFlabel.size() == 0

                    true =>  lineDraw.rTFlabel.put("High", label.new(time, TFhrdata.highTF, xloc = xloc.bar_time, 
                                                         textcolor = color.aqua, 
                                                         text      = tf + "H", 
                                                         size      = size.tiny, 
                                                         style     = label.style_label_left, 
                                                         color     = #00000000
                                                         )),
                             lineDraw.rTFlabel.put("Low" , label.new(time, TFhrdata.lowTF , xloc = xloc.bar_time, 
                                                         textcolor = color.aqua, 
                                                         text      = tf + "L", 
                                                         size      = size.tiny, 
                                                         style     = label.style_label_left, 
                                                         color     = #00000000
                                                         ))  

                    =>       lineDraw.rTFlabel.get("High") .set_xy(time, TFhrdata.highTF),
                             lineDraw.rTFlabel.get("Low")  .set_xy(time, TFhrdata.lowTF)


    [TFhrdata.volTF, volRolling]



tfDrawLower(bool showRollingLab, simple string tf, bool showLevels) => 

    simple int end = switch tf 

        "240" => 240
        "1D"  => 1440


    [o, h, l, c, v, t] = request.security_lower_tf(syminfo.tickerid, "1", [open, high, low, close, volume, time])


    var oArr = array.new_float()
    var hArr = array.new_float()
    var lArr = array.new_float()
    var cArr = array.new_float()
    var vArr = array.new_float()
    var tArr = array.new_int()

    TFhrdata = rollingTF.new(), var volRolling = array.new<float>()

    if h.size() > 0

        for i = 0 to h.size() - 1

            oArr.push(o.get(i))
            hArr.push(h.get(i))
            lArr.push(l.get(i))
            cArr.push(c.get(i))
            vArr.push(v.get(i))
            tArr.push(t.get(i))

            if hArr.size() > end 

                oArr.shift()
                hArr.shift()
                lArr.shift()
                cArr.shift()
                vArr.shift()
                tArr.shift()


        for i = 0 to hArr.size() - 1
        
            if showLevels

            
                getHigh = hArr.get(i), getLow = lArr.get(i), 
                             getTime = tArr.get(i)

                TFhrdata.highTF := math.max(TFhrdata.highTF, getHigh)
                TFhrdata.lowTF  := math.min(TFhrdata.lowTF , getLow)

                if TFhrdata.highTF == getHigh 
                
                    TFhrdata.highTFt := tArr.get(i)

                if TFhrdata.lowTF == getLow
                
                    TFhrdata.lowTFt  := tArr.get(i)

            TFhrdata.volTF  += vArr.get(i)

        volRolling.push(TFhrdata.volTF)

        var lineDraw = rollingTF.new(rTFdraw = map.new<string, line>(), rTFlabel = map.new<string, label>())

        if showLevels
        
            switch lineDraw.rTFdraw.size() == 0
            
                true =>  lineDraw.rTFdraw.put("High", line.new(TFhrdata.highTFt, TFhrdata.highTF, time, TFhrdata.highTF, 
                                                 xloc = xloc.bar_time, color = color.aqua)),
                         lineDraw.rTFdraw.put("Low" , line.new(TFhrdata.lowTFt , TFhrdata.lowTF , time, TFhrdata.lowTF , 
                                                 xloc = xloc.bar_time, color = color.aqua))  

                =>       lineDraw.rTFdraw.get("High").set_xy1(TFhrdata.highTFt, TFhrdata.highTF),
                         lineDraw.rTFdraw.get("High").set_xy2(time, TFhrdata.highTF),

                         lineDraw.rTFdraw.get("Low").set_xy1(TFhrdata.lowTFt, TFhrdata.lowTF),
                         lineDraw.rTFdraw.get("Low").set_xy2(time, TFhrdata.lowTF)

            if showRollingLab 
            
                switch lineDraw.rTFlabel.size() == 0
                
                    true =>  lineDraw.rTFlabel.put("High", label.new(time, TFhrdata.highTF, xloc = xloc.bar_time, 
                                                         textcolor = color.aqua, 
                                                         text      = tf + "H", 
                                                         size      = size.tiny, 
                                                         style     = label.style_label_left, 
                                                         color     = #00000000
                                                         )),
                             lineDraw.rTFlabel.put("Low" , label.new(time, TFhrdata.lowTF , xloc = xloc.bar_time, 
                                                         textcolor = color.aqua, 
                                                         text      = tf + "L", 
                                                         size      = size.tiny, 
                                                         style     = label.style_label_left, 
                                                         color     = #00000000
                                                         ))  

                    =>       lineDraw.rTFlabel.get("High") .set_xy(time, TFhrdata.highTF),
                             lineDraw.rTFlabel.get("Low")  .set_xy(time, TFhrdata.lowTF)


    [TFhrdata.volTF, volRolling]


calculatePivots(length)=>

    var int intraCalc = 0


    if bar_index > length + 1

        up  = highArr.slice(0, length).max()
        dn  = lowArr .slice(0, length).min() 
        
        cHi = highArr.get(length)
        cLo = lowArr .get(length)

        intraCalc := switch 

            cHi > up => 0 
            cLo < dn => 1 
            =>          intraCalc[1]

        topSwing = switch 

            intraCalc == 0 and intraCalc[1] != 0 => cHi 
            =>                                      0 

        botSwing = switch 

            intraCalc == 1 and intraCalc[1] != 1 => cLo
            =>                                      0 


        [topSwing, botSwing]


[bigUpper    , bigLower   ]     = calculatePivots(extSens)
[smallUpper  , smallLower ]     = calculatePivots(intSens)


var label [] upLabel = array.new_label(1)
var label [] dnLabel = array.new_label(1)


var box [] highBlock = array.new_box()
var box [] lowBlock  = array.new_box()



drawChar(x, y, str, col, down) =>

    style = switch down 

        true => label.style_label_down
        =>      label.style_label_up

    line.new (int(x), y, bar_index, y, color = col, style = line.style_dashed)
    label.new(math.round(math.avg(x, bar_index)), y, str, color = #00000000, textcolor = col, style = style, size = size.small)


drawStructureExt() => 

    var int counter = 0

    if bigUpper != 0
        bigData.put("upside", 1)
        x1 = bar_index - extSens

        txt = switch bigUpper > bigData.get("upaxis")
            
            true => 'HH'
            =>      'LH'

        if showHHLH

            upLabel.set(0, label.new(x1, bigUpper, txt,

                          color     = color.new(color.white, 100), 
                          textcolor = bearC, 
                          style     = label.style_label_down, 
                          size      = size.small
                          ))
        if showOB
            highBlock.push(box.new(x1, bigUpper, last_bar_index + 5, bigUpper * .998, 
                         border_color = color.new(color.red, 75), 
                         bgcolor      = color.new(color.red, 95)
                         ))

        bigData.put("upaxis" , bigUpper)
        bigData.put("upaxis2", x1)

        counter := 1

    if bigLower != 0
        bigData.put("downside", 1)

        x1 = bar_index - extSens

        txt = switch bigLower < bigData.get("dnaxis") 

            true => "LL" 
            =>      "HL"

        if showHLLL == true 
            dnLabel.set(0, label.new(x1, bigLower, txt, color = #ffffff00, 
                         textcolor = bullC, 
                         style     = label.style_label_up, 
                         size      = size.small
                         ))
        if showOB
            lowBlock.push(box.new(x1, bigLower, last_bar_index + 5, bigLower * 1.002,
                          border_color = color.new(color.blue, 75), 
                          bgcolor      = color.new(color.blue, 95)
                          ))    
        
        bigData.put("dnaxis" , bigLower)
        bigData.put("dnaxis2", x1)

        counter := -1


    if showExt
        if ta.crossover(close, bigData.get("upaxis"))
            if bigData.get("upside") != 0

                str = switch bigData.get("moving") < 0

                    true => extStru != "BoS"   ? 'CHoCH' : "" 
                    =>      extStru != 'CHoCH' ? 'BoS'   : ""

                if extStru == "All" or str.contains(extStru, str)
                    drawChar(bigData.get("upaxis2"), bigData.get("upaxis"), str, bullC, true)

                bigData.put("upside", 0)
                bigData.put("moving", 1)

        if ta.crossunder(close, bigData.get("dnaxis"))

            if bigData.get("downside") != 0

                str = switch bigData.get("moving") > 0

                    true => extStru != "BoS"   ? 'CHoCH' : "" 
                    =>      extStru != 'CHoCH' ? 'BoS'   : ""

                if extStru == "All" or str.contains(extStru, str)
                    drawChar(bigData.get("dnaxis2"), bigData.get("dnaxis"), str, bearC, false)

                bigData.put("downside", 0)
                bigData.put("moving", -1)

    counter 

counter = drawStructureExt()

method updateBox(array<box> id) =>

    if id.size() > 0 
        for i = 0 to id.size() - 1
            id.get(i).set_right(last_bar_index + 5)

method cleanseLevel(array<box> id, bool isHighBlock) => 

    if id.size() > 0   

        for i = id.size() - 1 to 0 

            condition = switch isHighBlock
            
                true => close >= id.get(i).get_top()
                =>      close <= id.get(i).get_bottom()

            if condition
                id.remove(i).delete()

        if id.size() > showLast and showLast != 0
            for i = id.size() - showLast to 0 
                id.remove(i).delete()

highBlock.cleanseLevel(true)
lowBlock .cleanseLevel(false)

if barstate.islast

    highBlock.updateBox()
    lowBlock .updateBox()



method updateMain(line id) => 

    hi = 0.0 
    lo = 1e8

    if showFibs

        [bigUpperFibs, bigLowerFibs]    = calculatePivots(25)

        var int counterFibs = 0

        if bigUpperFibs != 0 
            counterFibs := 1

        if bigLowerFibs != 0 
            counterFibs := -1

        if counterFibs == 1 
            hi := 0.0
            
            id.set_xy1(int(bigData.get("upaxis2")), bigData.get("upaxis"))

            for i = 0 to bar_index - int(bigData.get("dnaxis2"))

                getLow = lowArr.get(i)

                lo := math.min(getLow, lo)

                if lo == getLow
                    id.set_xy2(bar_index - i, lo)

        else if counterFibs == -1

            lo := 1e8
            id.set_xy1(int(bigData.get("dnaxis2")), bigData.get("dnaxis"))

            for i = 0 to bar_index - bigData.get("upaxis2")

                getHigh = highArr.get(i)
                hi     := math.max(highArr.get(i), hi)

                if hi == getHigh 

                    id.set_xy2(bar_index - i, hi)

        if id.get_x2() < id.get_x1()

            x2 = id.get_x2(), x1 = id.get_x1()
            y2 = id.get_y2(), y1 = id.get_y1(),

                     id.set_xy2(x1, y1),
                     id.set_xy1(x2, y2)


        switch id.get_y2() < id.get_y1()

            true => id.set_color(#F24968)
            =>      id.set_color(#14D990)

    0


var main = line.new(dnLabel.first().get_x(), dnLabel.first().get_y(), upLabel.first().get_x(), upLabel.first().get_y(),
                                                 style = line.style_dashed, 
                                                 width = 2
                                                 )


main.updateMain()

quickLine(getX2, y, color) => 

    line.new(getX2, y, bar_index + 5, y, color = color.new(color, 75))

quickLabel(y, txt, color) => 

    label.new(bar_index + 5, y, text = str.tostring(txt), color = #00000000, style = label.style_label_left, textcolor = color)

drawFibs() =>
    if barstate.islast
        // Initialize arrays for fib lines and labels
        var fibLine = array.new<line>(8)
        var fibLab = array.new<label>(8)
        
        // Clear existing lines and labels
        for i = 0 to array.size(fibLine) - 1
            line.delete(array.get(fibLine, i))
            label.delete(array.get(fibLab, i))

        if showFibs
            getY2 = main.get_y2()
            sub = main.get_y1() - getY2
            getX1 = main.get_x1()
            getX2 = main.get_x2()

            // Iterate and draw Fibonacci levels
            for i = 0 to array.size(fibLine) - 1
                mod = i % array.size(fibLine)  // Fix mod calculation for array size
                
                [y, col, txt] = switch mod
                    0 => [sub * fib0 + getY2, show0 ? fib0col : color.new(chart.bg_color, 100), fib0]
                    1 => [sub * fib1 + getY2, show236 ? fib1col : color.new(chart.bg_color, 100), fib1]
                    2 => [sub * fib2 + getY2, show382 ? fib2col : color.new(chart.bg_color, 100), fib2]
                    3 => [sub * fib3 + getY2, show5 ? fib3col : color.new(chart.bg_color, 100), fib3]
                    4 => [sub * fib4 + getY2, show618 ? fib4col : color.new(chart.bg_color, 100), fib4]
                    5 => [sub * fib5 + getY2, show786 ? fib5col : color.new(chart.bg_color, 100), fib5]
                    6 => [sub * fib6 + getY2, show1 ? fib6col : color.new(chart.bg_color, 100), fib6]
                    7 => [sub * fib7 + getY2, show1618 ? fib7col : color.new(chart.bg_color, 100), fib7]
                    =>  [na, color.new(chart.bg_color, 100), na]  // Default case

                // Define extended length
                length_extension = 100  // Adjust this value to extend the line length

                // Create and set new lines and labels dynamically
                line = line.new(x1=getX2 - length_extension, y1=y, x2=getX2 + length_extension, y2=y, color=col, width=2)
                label = label.new(x=getX2 + length_extension, y=y, text=str.tostring(txt), style=label.style_label_upper_left, color=col, textcolor=color.white)
                array.set(fibLine, i, line)
                array.set(fibLab, i, label)


drawFibs()


drawStructureInternals() => 

    if showInt
        
        var keyValues = map.new<string, float>()

        if keyValues.size() == 0 
            keyValues.put("movingSmall", 0)

        if smallUpper != 0 

            keyValues.put("upsideSmall", 1)          
            keyValues.put("upaxisSmall", smallUpper) 
            keyValues.put("upaxis2Small", bar_index - intSens)

        if smallLower != 0 

            keyValues.put("downsideSmall", 1)       
            keyValues.put("dnaxisSmall", smallLower)
            keyValues.put("dnaxis2Small", bar_index - intSens)


        if ta.crossover(close, keyValues.get("upaxisSmall")) 
            if keyValues.get("upsideSmall") != 0

                str = switch 

                    keyValues.get("movingSmall") < 0 =>     intStru != "BoS"   ? 'I-CHoCH' : "" 
                    =>                                      intStru != "CHoCH" ? 'I-BoS'   : ""

                if intStru == "All" or str.contains(str, intStru)

                    drawChar(keyValues.get("upaxis2Small"), keyValues.get("upaxisSmall"), str, bullC, true)

                keyValues.put("upsideSmall", 0)
                keyValues.put("movingSmall", 1)

        if ta.crossunder(close, keyValues.get("dnaxisSmall"))
            if keyValues.get("downsideSmall") != 0

                str = switch 

                    keyValues.get("movingSmall") > 0 => intStru != "BoS"   ? 'I-CHoCH' : ""
                    =>                                  intStru != "CHoCH" ? 'I-BoS'   : ""

                if intStru == "All" or str.contains(str, intStru)

                    drawChar(keyValues.get("dnaxis2Small"), keyValues.get("dnaxisSmall"), str, bearC, false)

                keyValues.put("downsideSmall", 0)
                keyValues.put("movingSmall", -1)


drawStructureInternals()


drawAOE() => 

    atr = ta.atr(14)

    if showAOE 

        if closeArr.size() > 50

            aoi    = closeArr.slice(0, 50) 
            aoi2   = openArr .slice(0, 50) 

            maxaoiH = math.max(aoi.max(), aoi2.max())
            minaoiL = math.min(aoi.min(), aoi2.min())

            var aoeLevels = map.new<string, box>()

            if aoeLevels.size() == 0 

                aoeLevels.put("High", 
                         
                             box.new(bar_index[50], maxaoiH * 1.01, bar_index + 5, maxaoiH, 
                             border_color = #00000000, 
                             bgcolor      = color.new(#F24968, 90), 
                             text         = "Area of Interest" , 
                             text_size    = size.small, 
                             text_color   = color.new(#F24968, 33) 
                             ))

                aoeLevels.put("Low", 
                         
                             box.new(bar_index[50], minaoiL, bar_index + 5, minaoiL * .99, 
                             border_color = #00000000, 
                             bgcolor      = color.new(#14D990, 90), 
                             text         = "Area of Interest" , 
                             text_size    = size.small, 
                             text_color   = color.new(#14D990, 33) 
                             ))

            getHighBox = aoeLevels.get("High")

            if close <= getHighBox.get_top() * 1.01

                getHighBox.set_lefttop      (bar_index[50], maxaoiH + atr)
                getHighBox.set_rightbottom  (bar_index + 5,  maxaoiH)
                getHighBox.set_text         ("Area of Interest")

            else 

                getHighBox.set_lefttop      (bar_index + 5, maxaoiH + atr)
                getHighBox.set_rightbottom  (bar_index + 5,  maxaoiH + atr)
                getHighBox.set_text         ("")

            getLowBox = aoeLevels.get("Low")

            if close >= getLowBox.get_bottom() * .99

                getLowBox.set_lefttop     (bar_index[50],  minaoiL)
                getLowBox.set_rightbottom (bar_index + 5,  minaoiL - atr)
                getLowBox.set_text        ("Area of Interest")
            else 

                getLowBox.set_lefttop     (bar_index + 5, minaoiL)
                getLowBox.set_rightbottom (bar_index + 5, - atr)
                getLowBox.set_text        ("")

drawAOE()


var table tab2 = table.new(position.top_right, 13, 13,  bgcolor = #20222C, border_color = #363843, frame_color = #363843, border_width = 1, frame_width = 1)

nyHour   = hour  (timenow, "Asia/Kolkata")
nyMinute = minute(timenow, "Asia/Kolkata")

fvg(direction) => 

    var fvgMat = matrix.new<float>(5), var fvgDrawings = array.new<box>()

    fvgMat.add_col(0, array.from(math.sign(close - open), close, high, low, time))

    if fvgMat.columns() > 3 
        fvgMat.remove_col(fvgMat.columns() - 1)

    if fvgMat.row(0).sum() == direction

        getDir = math.sign(direction)

        [y, y1] = switch getDir

            -1 => [fvgMat.get(3, 2), fvgMat.get(2, 0)]   
            =>    [fvgMat.get(3, 0), fvgMat.get(2, 2)]

        col = switch closeOnly
            true => #00000000
            =>      color.new(fvgcol, fvgtra)

        fvgDrawings.push(
             box.new(int(fvgMat.get(4, 1)),y, last_bar_time, y1, xloc = xloc.bar_time, 
                 border_color = col, bgcolor = col)
         )
        

    fvgDrawings

if showFVG

    fvgDn = fvg(-3)
    fvgUp = fvg(3)

    if fvgDn.size() > 0 

        for i = fvgDn.size() - 1 to 0

            getfvg = fvgDn.get(i)

            if high >= getfvg.get_top()
                getfvg.delete()
                fvgDn.remove(i)

            else if contract
                if high > getfvg.get_bottom()
                    getfvg.set_bottom(high)


    if fvgUp.size() > 0 

        for i = fvgUp.size() - 1 to 0

            getfvg = fvgUp.get(i)

            if low <= getfvg.get_bottom()
                getfvg.delete()
                fvgUp.remove(i)

            else if contract
                if low < getfvg.get_top()
                    getfvg.set_top(low)


    if closeOnly and barstate.islast 

        minDist = matrix.new<float>(1, 2, 20e20)

        if fvgDn.size() > 0 
            for i = fvgDn.size() - 1 to 0

                getBottom = fvgDn.get(i).get_bottom()

                minDist.set(0, 1, math.min(minDist.get(0, 1), math.abs(close - getBottom)))

                if math.abs(close - getBottom) == minDist.get(0, 1)
                    minDist.set(0, 0, i)

                fvgDn.get(i).set_right(fvgDn.get(i).get_left())

            fvgDn.get(int(minDist.get(0, 0))).set_bgcolor(color.new(fvgcol, fvgtra))
            fvgDn.get(int(minDist.get(0, 0))).set_border_color(color.new(fvgcol, fvgtra))
            fvgDn.get(int(minDist.get(0, 0))).set_right(last_bar_time)

        minDist.set(0, 0, 0)
        minDist.set(0, 1, 20e20)


        if fvgUp.size() > 0 
            for i = fvgUp.size() - 1 to 0

                getTop = fvgUp.get(i).get_top()

                minDist.set(0, 1, math.min(minDist.get(0, 1), math.abs(close - getTop)))

                if math.abs(close - getTop) == minDist.get(0, 1)
                    minDist.set(0, 0, i)

                fvgUp.get(i).set_right(fvgUp.get(i).get_left())


            fvgUp.get(int(minDist.get(0, 0))).set_bgcolor(color.new(fvgcol, fvgtra))
            fvgUp.get(int(minDist.get(0, 0))).set_border_color(color.new(fvgcol, fvgtra))
            fvgUp.get(int(minDist.get(0, 0))).set_right(last_bar_time)


method getActivity(array<float> id, float id2) => 

    if id.size() > 0

        volPerc1 = id.percentile_nearest_rank(10)
        volPerc2 = id.percentile_nearest_rank(33)
        volPerc3 = id.percentile_nearest_rank(50)
        volPerc4 = id.percentile_nearest_rank(66)
        volPerc5 = id.percentile_nearest_rank(90)

        log.warning(str.tostring(volPerc1) + "\n" + str.tostring(volPerc2) + "\n" + str.tostring(volPerc3) + "\n" + str.tostring(volPerc4) + "\n" + str.tostring(volPerc5))

        activity = switch 

            id2 <=  volPerc1 => "Very Low"   
            id2 <=  volPerc2 => "Low"   
            id2 <=  volPerc3 => "Average"   
            id2 <=  volPerc4 => "High"   
            =>                  "Very High"


        activity





PrevBars = input.bool(title = "Show previous highs and lows?", defval = false)
condition = not (timeframe.isweekly or timeframe.ismonthly)

h = request.security(syminfo.tickerid, "D", high, barmerge.gaps_off, barmerge.lookahead_on)
l = request.security(syminfo.tickerid, "D", low, barmerge.gaps_off, barmerge.lookahead_on)

// Draw lines from the previous highs and lows
newSession = ta.change(time('D'))
count = ta.barssince(newSession)

var line PrevHigh = na
var line PrevLow = na

length = 15 // Set the length of the lines to 300 bars

// Declare the labels outside the if block
var label prevHighLabel = na
var label prevLowLabel = na

if (newSession)
    // Create the lines for PDH and PDL
    PrevHigh := line.new(x1 = bar_index, y1 = h[1], x2 = bar_index + length, y2 = h[1], color = #1100ff, width = 4)
    PrevLow := line.new(x1 = bar_index, y1 = l[1], x2 = bar_index + length, y2 = l[1], color = #ff7402, width = 4)

    // Delete the previous labels if they exist
    if (not na(prevHighLabel)) 
        label.delete(prevHighLabel)
    if (not na(prevLowLabel)) 
        label.delete(prevLowLabel)



    // Create hardcoded labels at the end of the lines
    prevHighLabel := label.new(x = bar_index + length, y = h[1], text = "PDH", color = #1100ff, style = label.style_label_left, textcolor = color.white, size = size.small)
    prevLowLabel := label.new(x = bar_index + length, y = l[1], text = "PDL", color = #ff7402, style = label.style_label_left, textcolor = color.white, size = size.small)


    // Delete the previous lines if they exist
    if (not na(PrevHigh[1])) 
        line.delete(PrevHigh[1])
    if (not na(PrevLow[1])) 
        line.delete(PrevLow[1])

    // Set the x-location of the lines
    line.set_xloc(PrevHigh, time[count + 1], time[count + 1] + (length * 86400000), xloc.bar_time)
    line.set_xloc(PrevLow, time[count + 1], time[count + 1] + (length * 86400000), xloc.bar_time)






















// Configurable time frames for trends
timeFrame1 = input.timeframe("D", title="Time Frame 1")
timeFrame2 = input.timeframe("W", title="Time Frame 2")
timeFrame3 = input.timeframe("M", title="Time Frame 3")
timeFrame4 = input.timeframe("240", title="Time Frame 4") // 4H represented as 240 minutes
timeFrame5 = input.timeframe("60", title="Time Frame 5") // 1H represented as 60 minutes
timeFrame6 = input.timeframe("30", title="Time Frame 6")

// Calculate EMA for each time frame
fastEMA1 = ta.ema(request.security(syminfo.tickerid, timeFrame1, close), 10)
slowEMA1 = ta.ema(request.security(syminfo.tickerid, timeFrame1, close), 20)

fastEMA2 = ta.ema(request.security(syminfo.tickerid, timeFrame2, close), 10)
slowEMA2 = ta.ema(request.security(syminfo.tickerid, timeFrame2, close), 20)

fastEMA3 = ta.ema(request.security(syminfo.tickerid, timeFrame3, close), 10)
slowEMA3 = ta.ema(request.security(syminfo.tickerid, timeFrame3, close), 20)

fastEMA4 = ta.ema(request.security(syminfo.tickerid, timeFrame4, close), 10)
slowEMA4 = ta.ema(request.security(syminfo.tickerid, timeFrame4, close), 20)

fastEMA5 = ta.ema(request.security(syminfo.tickerid, timeFrame5, close), 10)
slowEMA5 = ta.ema(request.security(syminfo.tickerid, timeFrame5, close), 20)

fastEMA6 = ta.ema(request.security(syminfo.tickerid, timeFrame6, close), 10)
slowEMA6 = ta.ema(request.security(syminfo.tickerid, timeFrame6, close), 20)

// Determine trends for each time frame
isUptrend1 = fastEMA1 > slowEMA1
isDowntrend1 = fastEMA1 < slowEMA1

isUptrend2 = fastEMA2 > slowEMA2
isDowntrend2 = fastEMA2 < slowEMA2

isUptrend3 = fastEMA3 > slowEMA3
isDowntrend3 = fastEMA3 < slowEMA3

isUptrend4 = fastEMA4 > slowEMA4
isDowntrend4 = fastEMA4 < slowEMA4

isUptrend5 = fastEMA5 > slowEMA5
isDowntrend5 = fastEMA5 < slowEMA5

isUptrend6 = fastEMA6 > slowEMA6
isDowntrend6 = fastEMA6 < slowEMA6

// Create a table to display the trends
var table trendTable = table.new(position.top_right, 13, 13, bgcolor=color.rgb(32, 34, 44), border_color=color.rgb(54, 56, 67), frame_color=color.rgb(54, 56, 67), border_width=1, frame_width=1)

// Update table with trend data
table.cell(trendTable, 0, 0, "Time Frame", bgcolor=color.gray, text_color=color.white)
table.cell(trendTable, 0, 1, "Trend", bgcolor=color.gray, text_color=color.white)
table.cell(trendTable, 0, 2, "Strength", bgcolor=color.gray, text_color=color.white)
table.cell(trendTable, 0, 3, "Latest Crossover", bgcolor=color.gray, text_color=color.white)
table.cell(trendTable, 0, 4, "Time", bgcolor=color.gray, text_color=color.white)

// Helper function to determine crossover text
getCrossoverText() =>
    cross9_20_up ? "9/20 Up" : "None" 
    cross9_20_down ? "9/20 Down" :"None" 
    cross20_50_up ? "20/50 Up" :"None" 
    cross20_50_down ? "20/50 Down" :"None" 
    cross50_100_up ? "50/100 Up" :"None" 
    cross50_100_down ? "50/100 Down" :"None" 
    cross100_200_up ? "100/200 Up" :"None" 
    cross100_200_down ? "100/200 Down" : "None"

// Fill table rows
table.cell(trendTable, 1, 0, timeFrame1)
table.cell(trendTable, 1, 1, isUptrend1 ? "Uptrend" : isDowntrend1 ? "Downtrend" : "Neutral", bgcolor=isUptrend1 ? color.new(color.green, 85) : isDowntrend1 ? color.new(color.red, 85) : na)
table.cell(trendTable, 1, 2, "Strong", bgcolor=color.new(color.blue, 85))
table.cell(trendTable, 1, 3, getCrossoverText())
table.cell(trendTable, 1, 4, str.tostring(time, "yyyy-MM-dd HH:mm"))

table.cell(trendTable, 2, 0, timeFrame2)
table.cell(trendTable, 2, 1, isUptrend2 ? "Uptrend" : isDowntrend2 ? "Downtrend" : "Neutral", bgcolor=isUptrend2 ? color.new(color.green, 85) : isDowntrend2 ? color.new(color.red, 85) : na)
table.cell(trendTable, 2, 2, "Strong", bgcolor=color.new(color.blue, 85))
table.cell(trendTable, 2, 3, getCrossoverText())
table.cell(trendTable, 2, 4, str.tostring(time, "yyyy-MM-dd HH:mm"))

table.cell(trendTable, 3, 0, timeFrame3)
table.cell(trendTable, 3, 1, isUptrend3 ? "Uptrend" : isDowntrend3 ? "Downtrend" : "Neutral", bgcolor=isUptrend3 ? color.new(color.green, 85) : isDowntrend3 ? color.new(color.red, 85) : na)
table.cell(trendTable, 3, 2, "Strong", bgcolor=color.new(color.blue, 85))
table.cell(trendTable, 3, 3, getCrossoverText())
table.cell(trendTable, 3, 4, str.tostring(time, "yyyy-MM-dd HH:mm"))

table.cell(trendTable, 4, 0, timeFrame4)
table.cell(trendTable, 4, 1, isUptrend4 ? "Uptrend" : isDowntrend4 ? "Downtrend" : "Neutral", bgcolor=isUptrend4 ? color.new(color.green, 85) : isDowntrend4 ? color.new(color.red, 85) : na)
table.cell(trendTable, 4, 2, "Strong", bgcolor=color.new(color.blue, 85))
table.cell(trendTable, 4, 3, getCrossoverText())
table.cell(trendTable, 4, 4, str.tostring(time, "yyyy-MM-dd HH:mm"))

table.cell(trendTable, 5, 0, timeFrame5)
table.cell(trendTable, 5, 1, isUptrend5 ? "Uptrend" : isDowntrend5 ? "Downtrend" : "Neutral", bgcolor=isUptrend5 ? color.new(color.green, 85) : isDowntrend5 ? color.new(color.red, 85) : na)
table.cell(trendTable, 5, 2, "Strong", bgcolor=color.new(color.blue, 85))
table.cell(trendTable, 5, 3, getCrossoverText())
table.cell(trendTable, 5, 4, str.tostring(time, "yyyy-MM-dd HH:mm"))

table.cell(trendTable, 6, 0, timeFrame6)
table.cell(trendTable, 6, 1, isUptrend6 ? "Uptrend" : isDowntrend6 ? "Downtrend" : "Neutral", bgcolor=isUptrend6 ? color.new(color.green, 85) : isDowntrend6 ? color.new(color.red, 85) : na)
table.cell(trendTable, 6, 2, "Strong", bgcolor=color.new(color.blue, 85))
table.cell(trendTable, 6, 3, getCrossoverText())
table.cell(trendTable, 6, 4, str.tostring(time, "yyyy-MM-dd HH:mm"))











// ~~ Inputs {
tf       = input.timeframe("60","Timeframe", group="Higher Timeframe Candles")
numb     = input.int(4,"Amount of Candles",minval=0, maxval=20, group="Higher Timeframe Candles")+1
dn_col   = input.color(color.new(color.red,10), title="Dn", inline="Candles", group="Higher Timeframe Candles")
dn_wick  = input.color(color.new(color.red,0), title="Wick", inline="Candles", group="Higher Timeframe Candles")
up_col   = input.color(color.new(color.lime,10), title="Up",inline="Candles", group="Higher Timeframe Candles")
up_wick  = input.color(color.new(color.lime,0), title="Wick", inline="Candles", group="Higher Timeframe Candles")
Range    = input.bool(false,"Range High/Low", inline="range", group="Range")
Mid      = input.bool(true,"Range Mid", inline="range", group="Range")
high_col = input.color(color.red, title="High", inline="range 1", group="Range")
low_col  = input.color(color.lime, title="Low",inline="range 1", group="Range")
mid_col  = input.color(color.rgb(20, 69, 246), title="Mid",inline="range 1", group="Range")
loc      = input.int(1,"Location", group="Location Settings")

// ~~ Table Inputs {
showTable      = input.bool(true,title="Show Table", inline="tbl", group="Table")
TblSize        = input.string(size.normal,title="",options=[size.auto,size.tiny,size.small,size.normal,size.large,size.huge],inline="tbl", group="Table")
pos            = input.string(position.top_right, title="",options =[position.top_right,position.top_center,
 position.top_left,position.bottom_right,position.bottom_center,position.bottom_left,position.middle_right,position.middle_left],inline="tbl", group="Table")
textcolor      = input.color(color.white, title="Text",inline="tbl_col", group="Table")
bgcolor        = input.color(color.new(color.blue,30), title="Bg",inline="tbl_col", group="Table")
//~~~}
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}

// ~~ HTF Error Message {
tfs = str.tonumber(tf)
if str.tostring(tf) == "1D"
    tfs := 1440 
error = str.tonumber(timeframe.period)>=tfs
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}

// ~~ UDT {
type HTF
    array<box> candle
    array<line> wickH
    array<line> wickL
    array<float> hl  
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}

// ~~ Variables {
b = bar_index
var candle    = HTF.new(array.new<box>(numb),array.new<line>(numb),array.new<line>(numb),array.new<float>(numb*2))
[o,h,l,c]     = request.security(syminfo.ticker,tf,[open,high,low,close],lookahead=barmerge.lookahead_on)
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}

// ~~ Code {
if ta.change(o) //New candle declaration
    candle.candle.shift().delete()
    candle.wickH.shift().delete()
    candle.wickL.shift().delete()
    candle.hl.shift()
    candle.hl.shift()

    candle.candle.push(box.new(b+numb*4+loc,math.max(o,c),b+numb*4+loc+2,math.min(o,c),color(na),bgcolor=o>c?dn_col:up_col))
    candle.wickH.push(line.new(b+numb*4+loc+1,math.max(o,c),b+numb*4+loc+1,h,color=o>c?dn_col:up_col))
    candle.wickL.push(line.new(b+numb*4+loc+1,math.min(o,c),b+numb*4+loc+1,l,color=o>c?dn_col:up_col))
    candle.hl.push(h)
    candle.hl.push(l)
else // Relocate previous & current candles
    d = loc
    for [i,x] in candle.candle
        if i<numb-1
            x.set_left(b+d*2)
            x.set_right(b+d*2+2)
            candle.wickH.get(i).set_x1(b+d*2+1)
            candle.wickH.get(i).set_x2(b+d*2+1)
            candle.wickL.get(i).set_x1(b+d*2+1)
            candle.wickL.get(i).set_x2(b+d*2+1)
        else
            x.set_lefttop(b+d*2,math.max(o,c))
            x.set_rightbottom(b+d*2+2,math.min(o,c))
            x.set_bgcolor(o>c?dn_col:up_col)
            candle.wickH.get(i).set_xy1(b+d*2+1,math.max(o,c))
            candle.wickH.get(i).set_xy2(b+d*2+1,h)
            candle.wickH.get(i).set_color(o>c?dn_wick:up_wick)
            candle.wickL.get(i).set_xy1(b+d*2+1,math.min(o,c))
            candle.wickL.get(i).set_xy2(b+d*2+1,l)
            candle.wickL.get(i).set_color(o>c?dn_wick:up_wick)
            candle.hl.set(numb*2-2,h)
            candle.hl.set(numb*2-1,l)
        d += 2
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}

// ~~ Range {
if Range
    RangeHigh  = line.new(b,candle.hl.max(),b+numb*4+loc+2,candle.hl.max(),color=high_col,extend=extend.none)
    RangeLow   = line.new(b,candle.hl.min(),b+numb*4+loc+2,candle.hl.min(),color=low_col,extend=extend.none)
    (RangeHigh[1]).delete()
    (RangeLow[1]).delete()

if Mid    
    RangeMid = line.new(b,math.avg(candle.hl.max(),candle.hl.min()),b+numb*4+loc+2,math.avg(candle.hl.max(),candle.hl.min()),color=mid_col,extend=extend.none)
    (RangeMid[1]).delete()

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}
// ~~ Table { 
tbl            = table.new(pos, 2, 11, frame_color=chart.bg_color, frame_width=2, border_width=2, border_color=chart.bg_color)
if barstate.islast and showTable
    tbl.cell(0, 0, text=error?"Error":"TF", text_color=textcolor, bgcolor=bgcolor, text_size=TblSize)
    tbl.cell(0, 1, text=error?"The chart's timeframe must be less than the HTF '"+tf+"' timeframe. \n\nor please select a higher timeframe in the setting panel of the indicator.":str.tostring(timeframe.period), text_halign=text.align_center, bgcolor=bgcolor, text_color=textcolor, text_size=TblSize)
    tbl.cell(1, 0, text="HTF", text_color=textcolor, bgcolor=bgcolor, text_size=TblSize)
    tbl.cell(1, 1, text=str.tostring(tf), text_halign=text.align_center, bgcolor=bgcolor, text_color=textcolor, text_size=TblSize)
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}